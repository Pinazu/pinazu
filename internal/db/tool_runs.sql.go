// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tool_runs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const checkIfAllChildToolRunStatusAreCompleted = `-- name: CheckIfAllChildToolRunStatusAreCompleted :one
SELECT NOT EXISTS (
  SELECT 1
  FROM tool_runs
  WHERE parent_run_id = $1
    AND status NOT IN ('SUCCESS', 'FAILED')
) AS all_completed
`

func (q *Queries) CheckIfAllChildToolRunStatusAreCompleted(ctx context.Context, parentRunID pgtype.Text) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfAllChildToolRunStatusAreCompleted, parentRunID)
	var all_completed bool
	err := row.Scan(&all_completed)
	return all_completed, err
}

const createChildToolRunStatus = `-- name: CreateChildToolRunStatus :one
INSERT INTO tool_runs (connection_id, thread_id, agent_id, recipient_id, id, tool_id, input, parent_run_id)
VALUES ($1, $2, $3, $4, $5, (SELECT id FROM tools WHERE name = $6), $7, $8)
RETURNING id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at
`

type CreateChildToolRunStatusParams struct {
	ConnectionID uuid.UUID   `db:"connection_id" json:"connection_id"`
	ThreadID     uuid.UUID   `db:"thread_id" json:"thread_id"`
	AgentID      uuid.UUID   `db:"agent_id" json:"agent_id"`
	RecipientID  uuid.UUID   `db:"recipient_id" json:"recipient_id"`
	ID           string      `db:"id" json:"id"`
	Name         string      `db:"name" json:"name"`
	Input        JsonRaw     `db:"input" json:"input"`
	ParentRunID  pgtype.Text `db:"parent_run_id" json:"parent_run_id"`
}

func (q *Queries) CreateChildToolRunStatus(ctx context.Context, arg CreateChildToolRunStatusParams) (ToolRun, error) {
	row := q.db.QueryRow(ctx, createChildToolRunStatus,
		arg.ConnectionID,
		arg.ThreadID,
		arg.AgentID,
		arg.RecipientID,
		arg.ID,
		arg.Name,
		arg.Input,
		arg.ParentRunID,
	)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createToolRunStatus = `-- name: CreateToolRunStatus :one
INSERT INTO tool_runs (connection_id, thread_id, agent_id, recipient_id, id, tool_id, input)
VALUES ($1, $2, $3, $4, $5, (SELECT id FROM tools WHERE name = $6), $7)
RETURNING id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at
`

type CreateToolRunStatusParams struct {
	ConnectionID uuid.UUID `db:"connection_id" json:"connection_id"`
	ThreadID     uuid.UUID `db:"thread_id" json:"thread_id"`
	AgentID      uuid.UUID `db:"agent_id" json:"agent_id"`
	RecipientID  uuid.UUID `db:"recipient_id" json:"recipient_id"`
	ID           string    `db:"id" json:"id"`
	Name         string    `db:"name" json:"name"`
	Input        JsonRaw   `db:"input" json:"input"`
}

func (q *Queries) CreateToolRunStatus(ctx context.Context, arg CreateToolRunStatusParams) (ToolRun, error) {
	row := q.db.QueryRow(ctx, createToolRunStatus,
		arg.ConnectionID,
		arg.ThreadID,
		arg.AgentID,
		arg.RecipientID,
		arg.ID,
		arg.Name,
		arg.Input,
	)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteToolRunStatusByID = `-- name: DeleteToolRunStatusByID :exec
DELETE FROM tool_runs WHERE id = $1
`

func (q *Queries) DeleteToolRunStatusByID(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteToolRunStatusByID, id)
	return err
}

const getChildToolRunStatusByID = `-- name: GetChildToolRunStatusByID :one
SELECT id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at FROM tool_runs WHERE id = $1 AND parent_run_id IS NOT NULL LIMIT 1
`

func (q *Queries) GetChildToolRunStatusByID(ctx context.Context, id string) (ToolRun, error) {
	row := q.db.QueryRow(ctx, getChildToolRunStatusByID, id)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChildToolRunStatusByParentID = `-- name: GetChildToolRunStatusByParentID :many
SELECT id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at FROM tool_runs WHERE parent_run_id = $1 ORDER BY CASE WHEN id::text ~ '_[0-9]+$' THEN CAST(SUBSTRING(id::text FROM '_([0-9]+)$') AS INTEGER) ELSE 0 END
`

func (q *Queries) GetChildToolRunStatusByParentID(ctx context.Context, parentRunID pgtype.Text) ([]ToolRun, error) {
	rows, err := q.db.Query(ctx, getChildToolRunStatusByParentID, parentRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolRun{}
	for rows.Next() {
		var i ToolRun
		if err := rows.Scan(
			&i.ID,
			&i.ToolID,
			&i.ConnectionID,
			&i.ThreadID,
			&i.AgentID,
			&i.RecipientID,
			&i.Input,
			&i.Result,
			&i.Status,
			&i.Duration,
			&i.ParentRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestToolExecutionStatus = `-- name: GetLatestToolExecutionStatus :one
SELECT status, duration, created_at, updated_at
FROM tool_runs
WHERE tool_id = $1
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestToolExecutionStatusRow struct {
	Status    ToolRunStatus      `db:"status" json:"status"`
	Duration  pgtype.Float8      `db:"duration" json:"duration"`
	CreatedAt pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetLatestToolExecutionStatus(ctx context.Context, toolID uuid.UUID) (GetLatestToolExecutionStatusRow, error) {
	row := q.db.QueryRow(ctx, getLatestToolExecutionStatus, toolID)
	var i GetLatestToolExecutionStatusRow
	err := row.Scan(
		&i.Status,
		&i.Duration,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getToolExecutionCount = `-- name: GetToolExecutionCount :one
SELECT COUNT(*) as execution_count FROM tool_runs WHERE tool_id = $1
`

func (q *Queries) GetToolExecutionCount(ctx context.Context, toolID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getToolExecutionCount, toolID)
	var execution_count int64
	err := row.Scan(&execution_count)
	return execution_count, err
}

const getToolRunStatus = `-- name: GetToolRunStatus :many
SELECT id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at FROM tool_runs
`

func (q *Queries) GetToolRunStatus(ctx context.Context) ([]ToolRun, error) {
	rows, err := q.db.Query(ctx, getToolRunStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ToolRun{}
	for rows.Next() {
		var i ToolRun
		if err := rows.Scan(
			&i.ID,
			&i.ToolID,
			&i.ConnectionID,
			&i.ThreadID,
			&i.AgentID,
			&i.RecipientID,
			&i.Input,
			&i.Result,
			&i.Status,
			&i.Duration,
			&i.ParentRunID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToolRunStatusByID = `-- name: GetToolRunStatusByID :one
SELECT id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at FROM tool_runs WHERE id = $1 LIMIT 1
`

func (q *Queries) GetToolRunStatusByID(ctx context.Context, id string) (ToolRun, error) {
	row := q.db.QueryRow(ctx, getToolRunStatusByID, id)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isTempParallelToolManagement = `-- name: IsTempParallelToolManagement :one
SELECT EXISTS (
    SELECT 1
    FROM tool_runs tr
    JOIN tools t ON tr.tool_id = t.id
    WHERE tr.id = $1
    AND t.name = 'temp_parallel_tool_management'
) AS is_temp_parallel_tool
`

func (q *Queries) IsTempParallelToolManagement(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRow(ctx, isTempParallelToolManagement, id)
	var is_temp_parallel_tool bool
	err := row.Scan(&is_temp_parallel_tool)
	return is_temp_parallel_tool, err
}

const updateToolRunStatusByID = `-- name: UpdateToolRunStatusByID :one
UPDATE tool_runs
SET result = $1, status = $2, duration = $3
WHERE id = $4
RETURNING id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at
`

type UpdateToolRunStatusByIDParams struct {
	Result   JsonRaw       `db:"result" json:"result"`
	Status   ToolRunStatus `db:"status" json:"status"`
	Duration pgtype.Float8 `db:"duration" json:"duration"`
	ID       string        `db:"id" json:"id"`
}

func (q *Queries) UpdateToolRunStatusByID(ctx context.Context, arg UpdateToolRunStatusByIDParams) (ToolRun, error) {
	row := q.db.QueryRow(ctx, updateToolRunStatusByID,
		arg.Result,
		arg.Status,
		arg.Duration,
		arg.ID,
	)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateToolRunStatusToFailedByID = `-- name: UpdateToolRunStatusToFailedByID :one
UPDATE tool_runs
SET status = 'FAILED', duration = $1
WHERE id = $2
RETURNING id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at
`

type UpdateToolRunStatusToFailedByIDParams struct {
	Duration pgtype.Float8 `db:"duration" json:"duration"`
	ID       string        `db:"id" json:"id"`
}

func (q *Queries) UpdateToolRunStatusToFailedByID(ctx context.Context, arg UpdateToolRunStatusToFailedByIDParams) (ToolRun, error) {
	row := q.db.QueryRow(ctx, updateToolRunStatusToFailedByID, arg.Duration, arg.ID)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateToolRunStatusToRunningByID = `-- name: UpdateToolRunStatusToRunningByID :one
UPDATE tool_runs
SET status = 'RUNNING'
WHERE id = $1
RETURNING id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at
`

func (q *Queries) UpdateToolRunStatusToRunningByID(ctx context.Context, id string) (ToolRun, error) {
	row := q.db.QueryRow(ctx, updateToolRunStatusToRunningByID, id)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateToolRunStatusToSuccessByID = `-- name: UpdateToolRunStatusToSuccessByID :one
UPDATE tool_runs
SET status = 'SUCCESS', duration = $1
WHERE id = $2
RETURNING id, tool_id, connection_id, thread_id, agent_id, recipient_id, input, result, status, duration, parent_run_id, created_at, updated_at
`

type UpdateToolRunStatusToSuccessByIDParams struct {
	Duration pgtype.Float8 `db:"duration" json:"duration"`
	ID       string        `db:"id" json:"id"`
}

func (q *Queries) UpdateToolRunStatusToSuccessByID(ctx context.Context, arg UpdateToolRunStatusToSuccessByIDParams) (ToolRun, error) {
	row := q.db.QueryRow(ctx, updateToolRunStatusToSuccessByID, arg.Duration, arg.ID)
	var i ToolRun
	err := row.Scan(
		&i.ID,
		&i.ToolID,
		&i.ConnectionID,
		&i.ThreadID,
		&i.AgentID,
		&i.RecipientID,
		&i.Input,
		&i.Result,
		&i.Status,
		&i.Duration,
		&i.ParentRunID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
