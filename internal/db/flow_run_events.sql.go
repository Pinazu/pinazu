// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: flow_run_events.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFlowRunEvent = `-- name: CreateFlowRunEvent :one
INSERT INTO flow_run_events (
    event_id,
    flow_run_id,
    task_name,
    event_type,
    event_data,
    event_timestamp,
    source
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING event_id, flow_run_id, task_name, event_type, event_data, event_timestamp, source, created_at
`

type CreateFlowRunEventParams struct {
	EventID        uuid.UUID          `db:"event_id" json:"event_id"`
	FlowRunID      pgtype.UUID        `db:"flow_run_id" json:"flow_run_id"`
	TaskName       pgtype.Text        `db:"task_name" json:"task_name"`
	EventType      string             `db:"event_type" json:"event_type"`
	EventData      JsonRaw            `db:"event_data" json:"event_data"`
	EventTimestamp pgtype.Timestamptz `db:"event_timestamp" json:"event_timestamp"`
	Source         pgtype.Text        `db:"source" json:"source"`
}

func (q *Queries) CreateFlowRunEvent(ctx context.Context, arg CreateFlowRunEventParams) (FlowRunEvent, error) {
	row := q.db.QueryRow(ctx, createFlowRunEvent,
		arg.EventID,
		arg.FlowRunID,
		arg.TaskName,
		arg.EventType,
		arg.EventData,
		arg.EventTimestamp,
		arg.Source,
	)
	var i FlowRunEvent
	err := row.Scan(
		&i.EventID,
		&i.FlowRunID,
		&i.TaskName,
		&i.EventType,
		&i.EventData,
		&i.EventTimestamp,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFlowRunEvent = `-- name: DeleteFlowRunEvent :exec
DELETE FROM flow_run_events WHERE event_id = $1
`

func (q *Queries) DeleteFlowRunEvent(ctx context.Context, eventID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFlowRunEvent, eventID)
	return err
}

const deleteFlowRunEventsByFlowRun = `-- name: DeleteFlowRunEventsByFlowRun :exec
DELETE FROM flow_run_events WHERE flow_run_id = $1
`

func (q *Queries) DeleteFlowRunEventsByFlowRun(ctx context.Context, flowRunID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFlowRunEventsByFlowRun, flowRunID)
	return err
}

const deleteOldFlowRunEvents = `-- name: DeleteOldFlowRunEvents :exec
DELETE FROM flow_run_events 
WHERE event_timestamp < $1
`

func (q *Queries) DeleteOldFlowRunEvents(ctx context.Context, eventTimestamp pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldFlowRunEvents, eventTimestamp)
	return err
}

const getEventStats = `-- name: GetEventStats :one
SELECT 
    COUNT(*) as total_events,
    COUNT(DISTINCT flow_run_id) as unique_flow_runs,
    COUNT(*) FILTER (WHERE event_type = 'FlowRunRequest') as request_events,
    COUNT(*) FILTER (WHERE event_type = 'FlowRunStatusEvent') as status_events,
    COUNT(*) FILTER (WHERE event_type = 'TaskRunStatusEvent') as task_events
FROM flow_run_events 
WHERE event_timestamp >= $1
`

type GetEventStatsRow struct {
	TotalEvents    int64 `db:"total_events" json:"total_events"`
	UniqueFlowRuns int64 `db:"unique_flow_runs" json:"unique_flow_runs"`
	RequestEvents  int64 `db:"request_events" json:"request_events"`
	StatusEvents   int64 `db:"status_events" json:"status_events"`
	TaskEvents     int64 `db:"task_events" json:"task_events"`
}

func (q *Queries) GetEventStats(ctx context.Context, eventTimestamp pgtype.Timestamptz) (GetEventStatsRow, error) {
	row := q.db.QueryRow(ctx, getEventStats, eventTimestamp)
	var i GetEventStatsRow
	err := row.Scan(
		&i.TotalEvents,
		&i.UniqueFlowRuns,
		&i.RequestEvents,
		&i.StatusEvents,
		&i.TaskEvents,
	)
	return i, err
}

const getEventsBySource = `-- name: GetEventsBySource :many
SELECT event_id, flow_run_id, task_name, event_type, event_data, event_timestamp, source, created_at FROM flow_run_events 
WHERE source = $1 
ORDER BY event_timestamp DESC
LIMIT $2
`

type GetEventsBySourceParams struct {
	Source pgtype.Text `db:"source" json:"source"`
	Limit  int32       `db:"limit" json:"limit"`
}

func (q *Queries) GetEventsBySource(ctx context.Context, arg GetEventsBySourceParams) ([]FlowRunEvent, error) {
	rows, err := q.db.Query(ctx, getEventsBySource, arg.Source, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRunEvent{}
	for rows.Next() {
		var i FlowRunEvent
		if err := rows.Scan(
			&i.EventID,
			&i.FlowRunID,
			&i.TaskName,
			&i.EventType,
			&i.EventData,
			&i.EventTimestamp,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowRunEvent = `-- name: GetFlowRunEvent :one
SELECT event_id, flow_run_id, task_name, event_type, event_data, event_timestamp, source, created_at FROM flow_run_events WHERE event_id = $1
`

func (q *Queries) GetFlowRunEvent(ctx context.Context, eventID uuid.UUID) (FlowRunEvent, error) {
	row := q.db.QueryRow(ctx, getFlowRunEvent, eventID)
	var i FlowRunEvent
	err := row.Scan(
		&i.EventID,
		&i.FlowRunID,
		&i.TaskName,
		&i.EventType,
		&i.EventData,
		&i.EventTimestamp,
		&i.Source,
		&i.CreatedAt,
	)
	return i, err
}

const getFlowRunEventsByFlowRun = `-- name: GetFlowRunEventsByFlowRun :many
SELECT event_id, flow_run_id, task_name, event_type, event_data, event_timestamp, source, created_at FROM flow_run_events 
WHERE flow_run_id = $1 
ORDER BY event_timestamp ASC
`

func (q *Queries) GetFlowRunEventsByFlowRun(ctx context.Context, flowRunID pgtype.UUID) ([]FlowRunEvent, error) {
	rows, err := q.db.Query(ctx, getFlowRunEventsByFlowRun, flowRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRunEvent{}
	for rows.Next() {
		var i FlowRunEvent
		if err := rows.Scan(
			&i.EventID,
			&i.FlowRunID,
			&i.TaskName,
			&i.EventType,
			&i.EventData,
			&i.EventTimestamp,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowRunEventsByTask = `-- name: GetFlowRunEventsByTask :many
SELECT event_id, flow_run_id, task_name, event_type, event_data, event_timestamp, source, created_at FROM flow_run_events 
WHERE flow_run_id = $1 AND task_name = $2 
ORDER BY event_timestamp ASC
`

type GetFlowRunEventsByTaskParams struct {
	FlowRunID pgtype.UUID `db:"flow_run_id" json:"flow_run_id"`
	TaskName  pgtype.Text `db:"task_name" json:"task_name"`
}

func (q *Queries) GetFlowRunEventsByTask(ctx context.Context, arg GetFlowRunEventsByTaskParams) ([]FlowRunEvent, error) {
	rows, err := q.db.Query(ctx, getFlowRunEventsByTask, arg.FlowRunID, arg.TaskName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRunEvent{}
	for rows.Next() {
		var i FlowRunEvent
		if err := rows.Scan(
			&i.EventID,
			&i.FlowRunID,
			&i.TaskName,
			&i.EventType,
			&i.EventData,
			&i.EventTimestamp,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowRunEventsByType = `-- name: GetFlowRunEventsByType :many
SELECT event_id, flow_run_id, task_name, event_type, event_data, event_timestamp, source, created_at FROM flow_run_events 
WHERE flow_run_id = $1 AND event_type = $2 
ORDER BY event_timestamp ASC
`

type GetFlowRunEventsByTypeParams struct {
	FlowRunID pgtype.UUID `db:"flow_run_id" json:"flow_run_id"`
	EventType string      `db:"event_type" json:"event_type"`
}

func (q *Queries) GetFlowRunEventsByType(ctx context.Context, arg GetFlowRunEventsByTypeParams) ([]FlowRunEvent, error) {
	rows, err := q.db.Query(ctx, getFlowRunEventsByType, arg.FlowRunID, arg.EventType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRunEvent{}
	for rows.Next() {
		var i FlowRunEvent
		if err := rows.Scan(
			&i.EventID,
			&i.FlowRunID,
			&i.TaskName,
			&i.EventType,
			&i.EventData,
			&i.EventTimestamp,
			&i.Source,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentFlowRunEvents = `-- name: GetRecentFlowRunEvents :many
SELECT fre.event_id, fre.flow_run_id, fre.task_name, fre.event_type, fre.event_data, fre.event_timestamp, fre.source, fre.created_at, fr.flow_id, f.name as flow_name
FROM flow_run_events fre
JOIN flow_runs fr ON fre.flow_run_id = fr.flow_run_id
JOIN flows f ON fr.flow_id = f.id
WHERE fre.event_timestamp >= $1
ORDER BY fre.event_timestamp DESC
LIMIT $2
`

type GetRecentFlowRunEventsParams struct {
	EventTimestamp pgtype.Timestamptz `db:"event_timestamp" json:"event_timestamp"`
	Limit          int32              `db:"limit" json:"limit"`
}

type GetRecentFlowRunEventsRow struct {
	EventID        uuid.UUID          `db:"event_id" json:"event_id"`
	FlowRunID      pgtype.UUID        `db:"flow_run_id" json:"flow_run_id"`
	TaskName       pgtype.Text        `db:"task_name" json:"task_name"`
	EventType      string             `db:"event_type" json:"event_type"`
	EventData      JsonRaw            `db:"event_data" json:"event_data"`
	EventTimestamp pgtype.Timestamptz `db:"event_timestamp" json:"event_timestamp"`
	Source         pgtype.Text        `db:"source" json:"source"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	FlowID         uuid.UUID          `db:"flow_id" json:"flow_id"`
	FlowName       string             `db:"flow_name" json:"flow_name"`
}

func (q *Queries) GetRecentFlowRunEvents(ctx context.Context, arg GetRecentFlowRunEventsParams) ([]GetRecentFlowRunEventsRow, error) {
	rows, err := q.db.Query(ctx, getRecentFlowRunEvents, arg.EventTimestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentFlowRunEventsRow{}
	for rows.Next() {
		var i GetRecentFlowRunEventsRow
		if err := rows.Scan(
			&i.EventID,
			&i.FlowRunID,
			&i.TaskName,
			&i.EventType,
			&i.EventData,
			&i.EventTimestamp,
			&i.Source,
			&i.CreatedAt,
			&i.FlowID,
			&i.FlowName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
