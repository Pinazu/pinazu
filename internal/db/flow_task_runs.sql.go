// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: flow_task_runs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFlowTaskRun = `-- name: CreateFlowTaskRun :one
INSERT INTO flow_task_runs (
    flow_run_id,
    task_name,
    status,
    result_cache_key,
    max_retries
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries
`

type CreateFlowTaskRunParams struct {
	FlowRunID      uuid.UUID   `db:"flow_run_id" json:"flow_run_id"`
	TaskName       string      `db:"task_name" json:"task_name"`
	Status         FlowStatus  `db:"status" json:"status"`
	ResultCacheKey pgtype.Text `db:"result_cache_key" json:"result_cache_key"`
	MaxRetries     pgtype.Int4 `db:"max_retries" json:"max_retries"`
}

func (q *Queries) CreateFlowTaskRun(ctx context.Context, arg CreateFlowTaskRunParams) (FlowTaskRun, error) {
	row := q.db.QueryRow(ctx, createFlowTaskRun,
		arg.FlowRunID,
		arg.TaskName,
		arg.Status,
		arg.ResultCacheKey,
		arg.MaxRetries,
	)
	var i FlowTaskRun
	err := row.Scan(
		&i.FlowRunID,
		&i.TaskName,
		&i.Status,
		&i.Result,
		&i.ResultCacheKey,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.DurationSeconds,
		&i.RetryCount,
		&i.MaxRetries,
	)
	return i, err
}

const deleteFlowTaskRun = `-- name: DeleteFlowTaskRun :exec
DELETE FROM flow_task_runs WHERE flow_run_id = $1 AND task_name = $2
`

type DeleteFlowTaskRunParams struct {
	FlowRunID uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
	TaskName  string    `db:"task_name" json:"task_name"`
}

func (q *Queries) DeleteFlowTaskRun(ctx context.Context, arg DeleteFlowTaskRunParams) error {
	_, err := q.db.Exec(ctx, deleteFlowTaskRun, arg.FlowRunID, arg.TaskName)
	return err
}

const deleteFlowTaskRunsByFlowRun = `-- name: DeleteFlowTaskRunsByFlowRun :exec
DELETE FROM flow_task_runs WHERE flow_run_id = $1
`

func (q *Queries) DeleteFlowTaskRunsByFlowRun(ctx context.Context, flowRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFlowTaskRunsByFlowRun, flowRunID)
	return err
}

const getFailedFlowTaskRunsForRetry = `-- name: GetFailedFlowTaskRunsForRetry :many
SELECT flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries FROM flow_task_runs 
WHERE status = 'FAILED' 
AND retry_count < max_retries 
ORDER BY created_at ASC
`

func (q *Queries) GetFailedFlowTaskRunsForRetry(ctx context.Context) ([]FlowTaskRun, error) {
	rows, err := q.db.Query(ctx, getFailedFlowTaskRunsForRetry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTaskRun{}
	for rows.Next() {
		var i FlowTaskRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.TaskName,
			&i.Status,
			&i.Result,
			&i.ResultCacheKey,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.DurationSeconds,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTaskRun = `-- name: GetFlowTaskRun :one
SELECT flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries FROM flow_task_runs WHERE flow_run_id = $1 AND task_name = $2
`

type GetFlowTaskRunParams struct {
	FlowRunID uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
	TaskName  string    `db:"task_name" json:"task_name"`
}

func (q *Queries) GetFlowTaskRun(ctx context.Context, arg GetFlowTaskRunParams) (FlowTaskRun, error) {
	row := q.db.QueryRow(ctx, getFlowTaskRun, arg.FlowRunID, arg.TaskName)
	var i FlowTaskRun
	err := row.Scan(
		&i.FlowRunID,
		&i.TaskName,
		&i.Status,
		&i.Result,
		&i.ResultCacheKey,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.DurationSeconds,
		&i.RetryCount,
		&i.MaxRetries,
	)
	return i, err
}

const getFlowTaskRunByFlowRunAndName = `-- name: GetFlowTaskRunByFlowRunAndName :one
SELECT flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries FROM flow_task_runs 
WHERE flow_run_id = $1 AND task_name = $2
`

type GetFlowTaskRunByFlowRunAndNameParams struct {
	FlowRunID uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
	TaskName  string    `db:"task_name" json:"task_name"`
}

func (q *Queries) GetFlowTaskRunByFlowRunAndName(ctx context.Context, arg GetFlowTaskRunByFlowRunAndNameParams) (FlowTaskRun, error) {
	row := q.db.QueryRow(ctx, getFlowTaskRunByFlowRunAndName, arg.FlowRunID, arg.TaskName)
	var i FlowTaskRun
	err := row.Scan(
		&i.FlowRunID,
		&i.TaskName,
		&i.Status,
		&i.Result,
		&i.ResultCacheKey,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.DurationSeconds,
		&i.RetryCount,
		&i.MaxRetries,
	)
	return i, err
}

const getFlowTaskRunStats = `-- name: GetFlowTaskRunStats :one
SELECT 
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE status = 'SUCCESS') as success_count,
    COUNT(*) FILTER (WHERE status = 'FAILED') as failed_count,
    COUNT(*) FILTER (WHERE status = 'RUNNING') as running_count,
    COUNT(*) FILTER (WHERE status = 'PENDING') as pending_count,
    AVG(duration_seconds) FILTER (WHERE duration_seconds IS NOT NULL) as avg_duration
FROM flow_task_runs 
WHERE flow_run_id = $1
`

type GetFlowTaskRunStatsRow struct {
	TotalCount   int64   `db:"total_count" json:"total_count"`
	SuccessCount int64   `db:"success_count" json:"success_count"`
	FailedCount  int64   `db:"failed_count" json:"failed_count"`
	RunningCount int64   `db:"running_count" json:"running_count"`
	PendingCount int64   `db:"pending_count" json:"pending_count"`
	AvgDuration  float64 `db:"avg_duration" json:"avg_duration"`
}

func (q *Queries) GetFlowTaskRunStats(ctx context.Context, flowRunID uuid.UUID) (GetFlowTaskRunStatsRow, error) {
	row := q.db.QueryRow(ctx, getFlowTaskRunStats, flowRunID)
	var i GetFlowTaskRunStatsRow
	err := row.Scan(
		&i.TotalCount,
		&i.SuccessCount,
		&i.FailedCount,
		&i.RunningCount,
		&i.PendingCount,
		&i.AvgDuration,
	)
	return i, err
}

const getFlowTaskRunsByFlowRun = `-- name: GetFlowTaskRunsByFlowRun :many
SELECT flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries FROM flow_task_runs 
WHERE flow_run_id = $1 
ORDER BY created_at ASC
`

func (q *Queries) GetFlowTaskRunsByFlowRun(ctx context.Context, flowRunID uuid.UUID) ([]FlowTaskRun, error) {
	rows, err := q.db.Query(ctx, getFlowTaskRunsByFlowRun, flowRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTaskRun{}
	for rows.Next() {
		var i FlowTaskRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.TaskName,
			&i.Status,
			&i.Result,
			&i.ResultCacheKey,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.DurationSeconds,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowTaskRunsByStatus = `-- name: GetFlowTaskRunsByStatus :many
SELECT flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries FROM flow_task_runs 
WHERE status = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetFlowTaskRunsByStatus(ctx context.Context, status FlowStatus) ([]FlowTaskRun, error) {
	rows, err := q.db.Query(ctx, getFlowTaskRunsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTaskRun{}
	for rows.Next() {
		var i FlowTaskRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.TaskName,
			&i.Status,
			&i.Result,
			&i.ResultCacheKey,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.DurationSeconds,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunningFlowTaskRuns = `-- name: GetRunningFlowTaskRuns :many
SELECT flow_run_id, task_name, status, result, result_cache_key, error_message, created_at, updated_at, started_at, finished_at, duration_seconds, retry_count, max_retries FROM flow_task_runs 
WHERE status = 'RUNNING' 
ORDER BY created_at ASC
`

func (q *Queries) GetRunningFlowTaskRuns(ctx context.Context) ([]FlowTaskRun, error) {
	rows, err := q.db.Query(ctx, getRunningFlowTaskRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowTaskRun{}
	for rows.Next() {
		var i FlowTaskRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.TaskName,
			&i.Status,
			&i.Result,
			&i.ResultCacheKey,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.DurationSeconds,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementFlowTaskRunRetryCount = `-- name: IncrementFlowTaskRunRetryCount :exec
UPDATE flow_task_runs 
SET retry_count = retry_count + 1,
    status = 'PENDING',
    started_at = NULL,
    finished_at = NULL,
    error_message = NULL,
    updated_at = NOW()
WHERE flow_run_id = $1 AND task_name = $2
`

type IncrementFlowTaskRunRetryCountParams struct {
	FlowRunID uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
	TaskName  string    `db:"task_name" json:"task_name"`
}

func (q *Queries) IncrementFlowTaskRunRetryCount(ctx context.Context, arg IncrementFlowTaskRunRetryCountParams) error {
	_, err := q.db.Exec(ctx, incrementFlowTaskRunRetryCount, arg.FlowRunID, arg.TaskName)
	return err
}

const updateFlowTaskRunError = `-- name: UpdateFlowTaskRunError :exec
UPDATE flow_task_runs 
SET error_message = $3, 
    status = 'FAILED',
    finished_at = NOW(),
    duration_seconds = EXTRACT(EPOCH FROM (NOW() - started_at)),
    updated_at = NOW()
WHERE flow_run_id = $1 AND task_name = $2
`

type UpdateFlowTaskRunErrorParams struct {
	FlowRunID    uuid.UUID   `db:"flow_run_id" json:"flow_run_id"`
	TaskName     string      `db:"task_name" json:"task_name"`
	ErrorMessage pgtype.Text `db:"error_message" json:"error_message"`
}

func (q *Queries) UpdateFlowTaskRunError(ctx context.Context, arg UpdateFlowTaskRunErrorParams) error {
	_, err := q.db.Exec(ctx, updateFlowTaskRunError, arg.FlowRunID, arg.TaskName, arg.ErrorMessage)
	return err
}

const updateFlowTaskRunResult = `-- name: UpdateFlowTaskRunResult :exec
UPDATE flow_task_runs 
SET result = $3,
    result_cache_key = $4,
    status = 'SUCCESS',
    finished_at = NOW(),
    duration_seconds = EXTRACT(EPOCH FROM (NOW() - started_at)),
    updated_at = NOW()
WHERE flow_run_id = $1 AND task_name = $2
`

type UpdateFlowTaskRunResultParams struct {
	FlowRunID      uuid.UUID   `db:"flow_run_id" json:"flow_run_id"`
	TaskName       string      `db:"task_name" json:"task_name"`
	Result         JsonRaw     `db:"result" json:"result"`
	ResultCacheKey pgtype.Text `db:"result_cache_key" json:"result_cache_key"`
}

func (q *Queries) UpdateFlowTaskRunResult(ctx context.Context, arg UpdateFlowTaskRunResultParams) error {
	_, err := q.db.Exec(ctx, updateFlowTaskRunResult,
		arg.FlowRunID,
		arg.TaskName,
		arg.Result,
		arg.ResultCacheKey,
	)
	return err
}

const updateFlowTaskRunStatus = `-- name: UpdateFlowTaskRunStatus :exec
UPDATE flow_task_runs 
SET status = $1, 
    updated_at = NOW()
WHERE flow_run_id = $2 AND task_name = $3
`

type UpdateFlowTaskRunStatusParams struct {
	Status    FlowStatus `db:"status" json:"status"`
	FlowRunID uuid.UUID  `db:"flow_run_id" json:"flow_run_id"`
	TaskName  string     `db:"task_name" json:"task_name"`
}

func (q *Queries) UpdateFlowTaskRunStatus(ctx context.Context, arg UpdateFlowTaskRunStatusParams) error {
	_, err := q.db.Exec(ctx, updateFlowTaskRunStatus, arg.Status, arg.FlowRunID, arg.TaskName)
	return err
}

const updateFlowTaskRunStatusWithTimestamps = `-- name: UpdateFlowTaskRunStatusWithTimestamps :exec
UPDATE flow_task_runs 
SET status = $1, 
    updated_at = NOW(),
    started_at = CASE WHEN $1::text = 'RUNNING' AND started_at IS NULL THEN NOW() ELSE started_at END,
    finished_at = CASE WHEN $1::text IN ('SUCCESS', 'FAILED', 'SKIPPED') AND finished_at IS NULL THEN NOW() ELSE finished_at END
WHERE flow_run_id = $2 AND task_name = $3
`

type UpdateFlowTaskRunStatusWithTimestampsParams struct {
	Status    FlowStatus `db:"status" json:"status"`
	FlowRunID uuid.UUID  `db:"flow_run_id" json:"flow_run_id"`
	TaskName  string     `db:"task_name" json:"task_name"`
}

func (q *Queries) UpdateFlowTaskRunStatusWithTimestamps(ctx context.Context, arg UpdateFlowTaskRunStatusWithTimestampsParams) error {
	_, err := q.db.Exec(ctx, updateFlowTaskRunStatusWithTimestamps, arg.Status, arg.FlowRunID, arg.TaskName)
	return err
}
