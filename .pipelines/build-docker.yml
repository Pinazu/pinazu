
default:
  tags:
    - linux
    - self-hosted

workflow:
  rules:
    # On push to main branch or merge request targeting main
    # Run CI toward sandbox accounts
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH || ($CI_PIPELINE_SOURCE == "parent_pipeline" && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH)
      variables:
        AWS_ACCOUNT_ID: ${AWS_ACCOUNT_ID_GENAI_dev}
    # On tagging, run CI toward SIT accounts
    - if: $CI_COMMIT_TAG
      variables:
        AWS_ACCOUNT_ID: ${AWS_ACCOUNT_ID_GENAI_sit}
######################################################################
# Stages
######################################################################
stages:
  - provision
  - build
  - push

provision_image: 
  stage: provision
  image: 271540607717.dkr.ecr.ap-southeast-1.amazonaws.com/workflows/terramate:v0.13.3
  script: 
  - |
    echo "CI_PROJECT_PATH. ${CI_PROJECT_PATH}"
    echo "AWS ACCOUNT ID: ${AWS_ACCOUNT_ID}"
    export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s" \
      $(aws sts assume-role \
      --role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/infra-bootstrap-provisioning-role \
      --role-session-name GitLabRunner \
      --query "Credentials.[AccessKeyId,SecretAccessKey,SessionToken]" \
      --output text))
    echo "Target AWS Region ${AWS_DEFAULT_REGION}"
    ROOT_REPO_NAME="$(echo "${CI_PROJECT_PATH}" | tr '[:upper:]' '[:lower:]')"
    REPO_NAME="${ROOT_REPO_NAME}"
    echo "Generated ECR Repository Name ${REPO_NAME}"
    # If pipeline triggered by tag, use the tag as the image tag
    # Otherwise, use the commit short SHA as the image tag
    if [ -n "$CI_COMMIT_TAG" ]; then
      export DOCKER_TAG="${CI_COMMIT_TAG}"
    else
      export DOCKER_TAG="$(git describe --tags --abbrev=0 || echo "notag")-g${CI_COMMIT_SHORT_SHA}"
    fi
    echo "Using tag: ${DOCKER_TAG}"
    export REPO_NOT_FOUND=0
    aws ecr describe-repositories --region $AWS_DEFAULT_REGION --repository-names "${REPO_NAME}" || export REPO_NOT_FOUND=1
    echo "----------------------------------------"
    if [ ${REPO_NOT_FOUND} -ne 0 -a ${CREATE_ECR_REPO} -ne 0 ]; then
      echo "Repository '${REPO_NAME}' does not exist. Creating it..."
      aws ecr create-repository \
        --repository-name "${REPO_NAME}" \
        --region "${AWS_DEFAULT_REGION}" \
        --image-scanning-configuration scanOnPush=true \
        --image-tag-mutability IMMUTABLE \
        --tags "Key=gitlab_project_path,Value=${CI_PROJECT_PATH}"
      echo "Successfully created ECR repository: '${REPO_NAME}'."
    else
      echo "Repository '${REPO_NAME}' already exists. No action needed."
    fi
  - echo "ROOT_REPO_NAME=${ROOT_REPO_NAME}" >> build.env
  - echo "DOCKER_TAG=${DOCKER_TAG}" >> build.env
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        CREATE_ECR_REPO: "1"
    # Merge requests
    - if: $CI_PIPELINE_SOURCE == "parent_pipeline"
      variables:
        CREATE_ECR_REPO: "0"
    - if: $CI_COMMIT_TAG
      variables:
        CREATE_ECR_REPO: "1"
    - when: never
  artifacts:
    reports:
      dotenv: build.env

build:docker: 
  stage: build
  image: 271540607717.dkr.ecr.ap-southeast-1.amazonaws.com/secure-vl-base/buildah:latest
  dependencies:
    - provision_image
  parallel:
    matrix:
      - ARCH: [amd64, arm64]
  variables:
    # Use vfs with buildah. Docker offers overlayfs as a default, but Buildah
    # cannot stack overlayfs on top of another overlayfs filesystem.
    STORAGE_DRIVER: vfs
    BUILDAH_FORMAT: docker
    BUILDAH_ISOLATION: chroot
    KUBERNETES_NODE_SELECTOR_ARCH: kubernetes.io/arch=${ARCH}
  before_script:
    - |
      mkdir -p /etc/containers
      echo '{"default": [{ "type": "insecureAcceptAnything" }]}' > /etc/containers/policy.json
    - export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s
      AWS_SESSION_TOKEN=%s" $(aws sts assume-role --role-arn
      arn:aws:iam::${AWS_ACCOUNT_ID}:role/infra-bootstrap-provisioning-role
      --role-session-name GitLabRunner --query
      "Credentials.[AccessKeyId,SecretAccessKey,SessionToken]" --output text))
    - aws ecr get-login-password --region ap-southeast-1 | buildah login --username AWS --password-stdin 271540607717.dkr.ecr.ap-southeast-1.amazonaws.com
    - aws ecr get-login-password --region ap-southeast-1 | buildah login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.ap-southeast-1.amazonaws.com
  script: 
    - echo "Building Docker image for ${REPO_NAME}:${DOCKER_TAG}..."
    - export IMAGE_BASE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ROOT_REPO_NAME}"
    - 'echo "Using architecture: ${ARCH}"'
    - echo "IMAGE_WITH_TAG=${IMAGE_WITH_TAG}" >> build.env
    - buildah bud --platform linux/${ARCH} -t ${IMAGE_BASE_URI}:${DOCKER_TAG}-${ARCH} ${COMPONENT}
    - buildah push --format docker --storage-driver=vfs ${IMAGE_BASE_URI}:${DOCKER_TAG}-${ARCH} docker-archive:docker-image-${COMPONENT}-${ARCH}.tar
    - echo "Scanning Docker image with Trivy..."
    - trivy image --exit-code 1 --severity HIGH,CRITICAL --no-progress --ignore-unfixed --input docker-image-${COMPONENT}-${ARCH}.tar 
    - echo "Docker image ${IMAGE_BASE_URI}:${DOCKER_TAG}-${ARCH} built and scanned successfully."
    - echo "ROOT_REPO_NAME=${ROOT_REPO_NAME}" >> build.env
    - echo "DOCKER_TAG=${DOCKER_TAG}" >> build.env
  artifacts:
    paths:
      - docker-image-${COMPONENT}-${ARCH}.tar 
    expire_in: 2 hours
    reports:
      dotenv: build.env

push:docker:
  stage: push
  image: 271540607717.dkr.ecr.ap-southeast-1.amazonaws.com/secure-vl-base/buildah:latest
  dependencies:
    - build:docker
  variables:
    # Use vfs with buildah. Docker offers overlayfs as a default, but Buildah
    # cannot stack overlayfs on top of another overlayfs filesystem.
    STORAGE_DRIVER: vfs
    BUILDAH_FORMAT: docker
    BUILDAH_ISOLATION: chroot
  before_script:
    - |
      mkdir -p /etc/containers
      echo '{"default": [{ "type": "insecureAcceptAnything" }]}' > /etc/containers/policy.json
    - export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s
      AWS_SESSION_TOKEN=%s" $(aws sts assume-role --role-arn
      arn:aws:iam::${AWS_ACCOUNT_ID}:role/infra-bootstrap-provisioning-role
      --role-session-name GitLabRunner --query
      "Credentials.[AccessKeyId,SecretAccessKey,SessionToken]" --output text))
    - aws ecr get-login-password --region ap-southeast-1 | buildah login --username AWS --password-stdin 271540607717.dkr.ecr.ap-southeast-1.amazonaws.com
    - aws ecr get-login-password --region ap-southeast-1 | buildah login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.ap-southeast-1.amazonaws.com
  script:
    - export IMAGE_BASE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${ROOT_REPO_NAME}" 
    - echo "Pushing Docker image to ECR to repo ${IMAGE_BASE_URI} ..."
    - buildah pull --storage-driver=vfs docker-archive:docker-image-${COMPONENT}-amd64.tar
    - buildah pull --storage-driver=vfs docker-archive:docker-image-${COMPONENT}-arm64.tar
    - buildah push --format docker --storage-driver=vfs ${IMAGE_BASE_URI}:${DOCKER_TAG}-amd64
    - buildah push --format docker --storage-driver=vfs ${IMAGE_BASE_URI}:${DOCKER_TAG}-arm64
    - echo "Docker images ${IMAGE_BASE_URI}:${DOCKER_TAG}-amd64 and $${IMAGE_BASE_URI}:${DOCKER_TAG}-arm64 pushed successfully."
    - echo "Creating multi-arch manifest for ${IMAGE_BASE_URI}:${DOCKER_TAG} ..."
    - buildah manifest create --storage-driver=vfs ${IMAGE_BASE_URI}:${DOCKER_TAG} ${IMAGE_BASE_URI}:${DOCKER_TAG}-amd64 ${IMAGE_BASE_URI}:${DOCKER_TAG}-arm64
    - echo "Pushing multi-arch manifest to ECR ..."
    - buildah manifest push --format docker --storage-driver=vfs ${IMAGE_BASE_URI}:${DOCKER_TAG}
    - echo "Multi-arch manifest ${IMAGE_BASE_URI}:${DOCKER_TAG} pushed successfully."
    - echo "Docker image ${IMAGE_BASE_URI}:${DOCKER_TAG} pushed successfully."
    - echo "Remove ${PUSH_LATEST_TAG} tags from ECR ..."
    - aws ecr batch-delete-image --repository-name ${ROOT_REPO_NAME} --image-ids imageTag=${PUSH_LATEST_TAG} || echo "Image latest does not exist, skipping deletion."
    - echo "Create new ${PUSH_LATEST_TAG} manifest for ${COMPONENT} ..."
    - buildah manifest create --storage-driver=vfs ${IMAGE_BASE_URI}:${PUSH_LATEST_TAG} ${IMAGE_BASE_URI}:${DOCKER_TAG}-amd64 ${IMAGE_BASE_URI}:${DOCKER_TAG}-arm64
    - buildah manifest push --format docker --storage-driver=vfs ${IMAGE_BASE_URI}:${PUSH_LATEST_TAG}
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      variables:
        PUSH_LATEST_TAG: "main"
    - if: $CI_COMMIT_TAG
      variables:
        PUSH_LATEST_TAG: "latest"
