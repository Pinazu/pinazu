//go:build ignore

package main

import (
	"embed"
	"fmt"
	"os"
	"os/exec"
	"strings"

	"gopkg.in/yaml.v2"
)

// embed the current working directory in the binary
//
//go:embed events/*.yaml
var fs embed.FS

type eventType string

const (
	ConsumerEvent   eventType = "consumer"
	RequestResponse eventType = "request_response"
)

type eventFiles struct {
	Events []event `yaml:"events"`
}

type event struct {
	Name               string              `yaml:"name"`
	Type               eventType           `yaml:"type"`
	Description        string              `yaml:"description"`
	Subject            string              `yaml:"subject"`
	MessageFields      []eventMessageField `yaml:"messageFields"`
	CustomValidation   string              `yaml:"customValidation,omitempty"`
	ResponseFields     []eventMessageField `yaml:"responseFields,omitempty"`
	ResponseValidation string              `yaml:"responseValidation,omitempty"`
	WebSocketEvent     bool                `yaml:"websocketEvent,omitempty"`
}

type eventMessageField struct {
	Name        string `yaml:"name"`
	Description string `yaml:"description"`
	Type        string `yaml:"type"`
	Import      string `yaml:"import,omitempty"`
	Optional    bool   `yaml:"optional,omitempty"`
}

// helper function convert from PascalCase to snake_case
func toSnakeCase(s string) string {
	var result string
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result += "_"
		}
		result += string(r)
	}
	return strings.ToLower(result)
}

func main() {
	// Get the current working directory
	wd, err := os.Getwd()
	if err != nil {
		fmt.Printf("Error getting working directory: %v\n", err)
		return
	}

	// List files in the embedded events directory
	files, err := fs.ReadDir("events")
	if err != nil {
		fmt.Printf("Error reading embedded events directory: %v\n", err)
		return
	}
	events := make([]event, 0, len(files))
	fmt.Println("Embedded event files:")
	for _, file := range files {
		if !file.IsDir() {
			fmt.Println(file.Name())
			// Read the file content
			data, err := fs.ReadFile("events/" + file.Name())
			if err != nil {
				fmt.Printf("Error reading file %s: %v\n", file.Name(), err)
				continue
			}
			// Parse the event from the YAML content
			var evt eventFiles
			if err := yaml.Unmarshal(data, &evt); err != nil {
				fmt.Printf("Error parsing event %s: %v\n", file.Name(), err)
				continue
			}
			if len(evt.Events) > 0 {
				// Extend the events slice with the parsed events
				events = append(events, evt.Events...)
			}
		}
	}
	fmt.Printf("Found %d events\n", len(events))

	// Writing a go file to the current working directory
	outputFile := "events.go"
	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Printf("Error creating output file: %v\n", err)
		return
	}
	defer f.Close()
	// Write generated headers
	header := `// Code generated by api/generate_event.go. DO NOT EDIT.
// versions:
//   pinazu current

package service
`
	if _, err := f.WriteString(header); err != nil {
		fmt.Printf("Error writing header to file: %v\n", err)
		return
	}
	importBlock := make(map[string]int, 0)
	constBlock := make([]string, 0, len(events))
	eventDefBlock := make([]string, 0, len(events))

	for _, evt := range events {
		eventSuffix := "Event"
		if evt.Type == RequestResponse {
			eventSuffix = "RequestEvent"
		}

		constBlock = append(constBlock, fmt.Sprintf("%s%sSubject  EventSubject = \"%s\"", evt.Name, eventSuffix, evt.Subject))
		eventDef := fmt.Sprintf("type %s%sMessage struct {\n", evt.Name, eventSuffix)
		for _, field := range evt.MessageFields {
			if field.Import != "" {
				importBlock[field.Import] = 1
			}
			eventDef += fmt.Sprintf("\t%s %s `json:\"%s%s\"`\n", field.Name, field.Type, toSnakeCase(field.Name), func() string {
				if field.Optional {
					return ",omitempty"
				}
				return ""
			}())
		}
		eventDef += "}\n\n"
		// Add Certain implementations
		eventDef += fmt.Sprintf("// Subject returns the event subject for %s events\n", evt.Name)
		eventDef += fmt.Sprintf("func (msg *%s%sMessage) Subject() EventSubject {\n", evt.Name, eventSuffix)
		eventDef += fmt.Sprintf("\treturn %s%sSubject\n", evt.Name, eventSuffix)
		eventDef += "}\n\n"

		// Add Validation function
		eventDef += fmt.Sprintf("// Validate checks if the %s event message is valid\n", evt.Name)
		eventDef += fmt.Sprintf("func (msg *%s%sMessage) Validate() error {\n", evt.Name, eventSuffix)
		eventDef += "\tif msg == nil {\n"
		eventDef += "\t\treturn fmt.Errorf(\"message is nil\")\n"
		eventDef += "\t}\n"
		if evt.CustomValidation != "" {
			eventDef += fmt.Sprintf("\t%s\n", evt.CustomValidation)
		}
		eventDef += "\treturn nil\n"
		eventDef += "}\n\n"

		// Add SubjectWithUser method for WebSocket events
		if evt.WebSocketEvent {
			eventDef += "// SubjectWithUser returns the subject with user ID appended for WebSocket routing\n"
			eventDef += fmt.Sprintf("func (msg *%s%sMessage) SubjectWithUser(userID uuid.UUID) EventSubject {\n", evt.Name, eventSuffix)
			eventDef += fmt.Sprintf("\treturn EventSubject(%s%sSubject.String() + \".\" + userID.String())\n", evt.Name, eventSuffix)
			eventDef += "}\n\n"
			// Add uuid import since we use uuid.UUID
			importBlock["github.com/google/uuid"] = 1
		}
		// Add the response event definition
		if evt.Type == RequestResponse {
			eventDef += fmt.Sprintf("type %sResponseEventMessage struct {\n", evt.Name)
			for _, field := range evt.ResponseFields {
				if field.Import != "" {
					importBlock[field.Import] = 1
				}
				eventDef += fmt.Sprintf("\t%s %s `json:\"%s%s\"`\n", field.Name, field.Type, toSnakeCase(field.Name), func() string {
					if field.Optional {
						return ",omitempty"
					}
					return ""
				}())
			}
			eventDef += "}\n\n"

			eventDef += fmt.Sprintf("// Subject returns the event subject for %s response events\n", evt.Name)
			eventDef += fmt.Sprintf("func (msg *%sResponseEventMessage) Subject() EventSubject {\n", evt.Name)
			eventDef += fmt.Sprintf("\treturn %sRequestEventSubject\n", evt.Name)
			eventDef += "}\n\n"
			eventDef += fmt.Sprintf("// Validate checks if the %s response event message is valid\n", evt.Name)
			eventDef += fmt.Sprintf("func (msg *%sResponseEventMessage) Validate() error {\n", evt.Name)
			eventDef += "\tif msg == nil {\n"
			eventDef += "\t\treturn fmt.Errorf(\"message is nil\")\n"
			eventDef += "\t}\n"
			if evt.ResponseValidation != "" {
				eventDef += fmt.Sprintf("\t%s\n", evt.ResponseValidation)
			}
			eventDef += "\treturn nil\n"
			eventDef += "}\n\n"
		}

		eventDefBlock = append(eventDefBlock, eventDef)
	}

	// Write the import block
	if len(importBlock) > 0 {
		fmt.Fprintln(f, "import (")
		for imp := range importBlock {
			fmt.Fprintf(f, "\t\"%s\"\n", imp)
		}
		fmt.Fprintln(f, ")")
	}

	// Write the const block
	fmt.Fprintln(f, "\nconst (")
	for _, line := range constBlock {
		fmt.Fprintln(f, "\t"+line)
	}
	fmt.Fprintln(f, ")")

	// Write the event definitions
	fmt.Fprintln(f, "\n// Event definitions")
	for _, def := range eventDefBlock {
		fmt.Fprint(f, def)
	}

	fmt.Println("Generated events written to", outputFile)
	// Run go fmt to format the file
	err = exec.Command("go", "run", "golang.org/x/tools/cmd/goimports", "-w", outputFile).Run()
	if err != nil {
		fmt.Printf("Error running go fmt: %v\n", err)
		return
	}

	// Print the current working directory
	fmt.Printf("Current working directory: %s\n", wd)
}
