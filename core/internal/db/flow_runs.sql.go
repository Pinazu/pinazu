// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: flow_runs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFlowRun = `-- name: CreateFlowRun :one
INSERT INTO flow_runs (
    flow_run_id,
    flow_id,
    parameters,
    status,
    engine,
    task_statuses,
    success_task_results,
    max_retries
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING flow_run_id, flow_id, parameters, status, engine, created_at, updated_at, started_at, finished_at, task_statuses, success_task_results, error_message, retry_count, max_retries
`

type CreateFlowRunParams struct {
	FlowRunID          uuid.UUID   `db:"flow_run_id" json:"flow_run_id"`
	FlowID             uuid.UUID   `db:"flow_id" json:"flow_id"`
	Parameters         JsonRaw     `db:"parameters" json:"parameters"`
	Status             FlowStatus  `db:"status" json:"status"`
	Engine             string      `db:"engine" json:"engine"`
	TaskStatuses       JsonRaw     `db:"task_statuses" json:"task_statuses"`
	SuccessTaskResults JsonRaw     `db:"success_task_results" json:"success_task_results"`
	MaxRetries         pgtype.Int4 `db:"max_retries" json:"max_retries"`
}

func (q *Queries) CreateFlowRun(ctx context.Context, arg CreateFlowRunParams) (FlowRun, error) {
	row := q.db.QueryRow(ctx, createFlowRun,
		arg.FlowRunID,
		arg.FlowID,
		arg.Parameters,
		arg.Status,
		arg.Engine,
		arg.TaskStatuses,
		arg.SuccessTaskResults,
		arg.MaxRetries,
	)
	var i FlowRun
	err := row.Scan(
		&i.FlowRunID,
		&i.FlowID,
		&i.Parameters,
		&i.Status,
		&i.Engine,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TaskStatuses,
		&i.SuccessTaskResults,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
	)
	return i, err
}

const deleteFlowRun = `-- name: DeleteFlowRun :exec
DELETE FROM flow_runs WHERE flow_run_id = $1
`

func (q *Queries) DeleteFlowRun(ctx context.Context, flowRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFlowRun, flowRunID)
	return err
}

const deleteOldFlowRuns = `-- name: DeleteOldFlowRuns :exec
DELETE FROM flow_runs 
WHERE created_at < $1 
AND status IN ('SUCCESS', 'FAILED')
`

func (q *Queries) DeleteOldFlowRuns(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldFlowRuns, createdAt)
	return err
}

const getFailedFlowRunsForRetry = `-- name: GetFailedFlowRunsForRetry :many
SELECT flow_run_id, flow_id, parameters, status, engine, created_at, updated_at, started_at, finished_at, task_statuses, success_task_results, error_message, retry_count, max_retries FROM flow_runs 
WHERE status = 'FAILED' 
AND retry_count < max_retries 
ORDER BY created_at ASC
`

func (q *Queries) GetFailedFlowRunsForRetry(ctx context.Context) ([]FlowRun, error) {
	rows, err := q.db.Query(ctx, getFailedFlowRunsForRetry)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRun{}
	for rows.Next() {
		var i FlowRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.FlowID,
			&i.Parameters,
			&i.Status,
			&i.Engine,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TaskStatuses,
			&i.SuccessTaskResults,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowRun = `-- name: GetFlowRun :one
SELECT flow_run_id, flow_id, parameters, status, engine, created_at, updated_at, started_at, finished_at, task_statuses, success_task_results, error_message, retry_count, max_retries FROM flow_runs WHERE flow_run_id = $1
`

func (q *Queries) GetFlowRun(ctx context.Context, flowRunID uuid.UUID) (FlowRun, error) {
	row := q.db.QueryRow(ctx, getFlowRun, flowRunID)
	var i FlowRun
	err := row.Scan(
		&i.FlowRunID,
		&i.FlowID,
		&i.Parameters,
		&i.Status,
		&i.Engine,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
		&i.TaskStatuses,
		&i.SuccessTaskResults,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.MaxRetries,
	)
	return i, err
}

const getFlowRunsByFlowID = `-- name: GetFlowRunsByFlowID :many
SELECT flow_run_id, flow_id, parameters, status, engine, created_at, updated_at, started_at, finished_at, task_statuses, success_task_results, error_message, retry_count, max_retries FROM flow_runs 
WHERE flow_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetFlowRunsByFlowID(ctx context.Context, flowID uuid.UUID) ([]FlowRun, error) {
	rows, err := q.db.Query(ctx, getFlowRunsByFlowID, flowID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRun{}
	for rows.Next() {
		var i FlowRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.FlowID,
			&i.Parameters,
			&i.Status,
			&i.Engine,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TaskStatuses,
			&i.SuccessTaskResults,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFlowRunsByStatus = `-- name: GetFlowRunsByStatus :many
SELECT flow_run_id, flow_id, parameters, status, engine, created_at, updated_at, started_at, finished_at, task_statuses, success_task_results, error_message, retry_count, max_retries FROM flow_runs 
WHERE status = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetFlowRunsByStatus(ctx context.Context, status FlowStatus) ([]FlowRun, error) {
	rows, err := q.db.Query(ctx, getFlowRunsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRun{}
	for rows.Next() {
		var i FlowRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.FlowID,
			&i.Parameters,
			&i.Status,
			&i.Engine,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TaskStatuses,
			&i.SuccessTaskResults,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingFlowRuns = `-- name: GetPendingFlowRuns :many
SELECT flow_run_id, flow_id, parameters, status, engine, created_at, updated_at, started_at, finished_at, task_statuses, success_task_results, error_message, retry_count, max_retries FROM flow_runs 
WHERE status IN ('SCHEDULED', 'PENDING') 
ORDER BY created_at ASC
`

func (q *Queries) GetPendingFlowRuns(ctx context.Context) ([]FlowRun, error) {
	rows, err := q.db.Query(ctx, getPendingFlowRuns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FlowRun{}
	for rows.Next() {
		var i FlowRun
		if err := rows.Scan(
			&i.FlowRunID,
			&i.FlowID,
			&i.Parameters,
			&i.Status,
			&i.Engine,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TaskStatuses,
			&i.SuccessTaskResults,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementFlowRunRetryCount = `-- name: IncrementFlowRunRetryCount :exec
UPDATE flow_runs 
SET retry_count = retry_count + 1,
    status = 'SCHEDULED',
    started_at = NULL,
    finished_at = NULL,
    updated_at = NOW()
WHERE flow_run_id = $1
`

func (q *Queries) IncrementFlowRunRetryCount(ctx context.Context, flowRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementFlowRunRetryCount, flowRunID)
	return err
}

const listFlowRuns = `-- name: ListFlowRuns :many
SELECT fr.flow_run_id, fr.flow_id, fr.parameters, fr.status, fr.engine, fr.created_at, fr.updated_at, fr.started_at, fr.finished_at, fr.task_statuses, fr.success_task_results, fr.error_message, fr.retry_count, fr.max_retries, f.name as flow_name, f.description as flow_description
FROM flow_runs fr
JOIN flows f ON fr.flow_id = f.id
ORDER BY fr.created_at DESC
LIMIT $1 OFFSET $2
`

type ListFlowRunsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListFlowRunsRow struct {
	FlowRunID          uuid.UUID          `db:"flow_run_id" json:"flow_run_id"`
	FlowID             uuid.UUID          `db:"flow_id" json:"flow_id"`
	Parameters         JsonRaw            `db:"parameters" json:"parameters"`
	Status             FlowStatus         `db:"status" json:"status"`
	Engine             string             `db:"engine" json:"engine"`
	CreatedAt          pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	StartedAt          pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt         pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	TaskStatuses       JsonRaw            `db:"task_statuses" json:"task_statuses"`
	SuccessTaskResults JsonRaw            `db:"success_task_results" json:"success_task_results"`
	ErrorMessage       pgtype.Text        `db:"error_message" json:"error_message"`
	RetryCount         pgtype.Int4        `db:"retry_count" json:"retry_count"`
	MaxRetries         pgtype.Int4        `db:"max_retries" json:"max_retries"`
	FlowName           string             `db:"flow_name" json:"flow_name"`
	FlowDescription    pgtype.Text        `db:"flow_description" json:"flow_description"`
}

func (q *Queries) ListFlowRuns(ctx context.Context, arg ListFlowRunsParams) ([]ListFlowRunsRow, error) {
	rows, err := q.db.Query(ctx, listFlowRuns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFlowRunsRow{}
	for rows.Next() {
		var i ListFlowRunsRow
		if err := rows.Scan(
			&i.FlowRunID,
			&i.FlowID,
			&i.Parameters,
			&i.Status,
			&i.Engine,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TaskStatuses,
			&i.SuccessTaskResults,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.MaxRetries,
			&i.FlowName,
			&i.FlowDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlowRunError = `-- name: UpdateFlowRunError :exec
UPDATE flow_runs 
SET error_message = $2, 
    status = 'FAILED',
    finished_at = NOW(),
    updated_at = NOW()
WHERE flow_run_id = $1
`

type UpdateFlowRunErrorParams struct {
	FlowRunID    uuid.UUID   `db:"flow_run_id" json:"flow_run_id"`
	ErrorMessage pgtype.Text `db:"error_message" json:"error_message"`
}

func (q *Queries) UpdateFlowRunError(ctx context.Context, arg UpdateFlowRunErrorParams) error {
	_, err := q.db.Exec(ctx, updateFlowRunError, arg.FlowRunID, arg.ErrorMessage)
	return err
}

const updateFlowRunStartedAt = `-- name: UpdateFlowRunStartedAt :exec
UPDATE flow_runs 
SET started_at = NOW(),
    updated_at = NOW()
WHERE flow_run_id = $1 AND started_at IS NULL
`

func (q *Queries) UpdateFlowRunStartedAt(ctx context.Context, flowRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateFlowRunStartedAt, flowRunID)
	return err
}

const updateFlowRunStatus = `-- name: UpdateFlowRunStatus :exec
UPDATE flow_runs 
SET status = $1, 
    updated_at = NOW()
WHERE flow_run_id = $2
`

type UpdateFlowRunStatusParams struct {
	Status    FlowStatus `db:"status" json:"status"`
	FlowRunID uuid.UUID  `db:"flow_run_id" json:"flow_run_id"`
}

func (q *Queries) UpdateFlowRunStatus(ctx context.Context, arg UpdateFlowRunStatusParams) error {
	_, err := q.db.Exec(ctx, updateFlowRunStatus, arg.Status, arg.FlowRunID)
	return err
}

const updateFlowRunStatusWithTimestamps = `-- name: UpdateFlowRunStatusWithTimestamps :exec
UPDATE flow_runs 
SET status = $1::text, 
    updated_at = NOW(),
    started_at = CASE WHEN $1::text = 'RUNNING' AND started_at IS NULL THEN NOW() ELSE started_at END,
    finished_at = CASE WHEN $1::text IN ('SUCCESS', 'FAILED') AND finished_at IS NULL THEN NOW() ELSE finished_at END
WHERE flow_run_id = $2
`

type UpdateFlowRunStatusWithTimestampsParams struct {
	Status    string    `db:"status" json:"status"`
	FlowRunID uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
}

func (q *Queries) UpdateFlowRunStatusWithTimestamps(ctx context.Context, arg UpdateFlowRunStatusWithTimestampsParams) error {
	_, err := q.db.Exec(ctx, updateFlowRunStatusWithTimestamps, arg.Status, arg.FlowRunID)
	return err
}

const updateFlowRunSuccessResults = `-- name: UpdateFlowRunSuccessResults :exec
UPDATE flow_runs 
SET success_task_results = $2, 
    updated_at = NOW()
WHERE flow_run_id = $1
`

type UpdateFlowRunSuccessResultsParams struct {
	FlowRunID          uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
	SuccessTaskResults JsonRaw   `db:"success_task_results" json:"success_task_results"`
}

func (q *Queries) UpdateFlowRunSuccessResults(ctx context.Context, arg UpdateFlowRunSuccessResultsParams) error {
	_, err := q.db.Exec(ctx, updateFlowRunSuccessResults, arg.FlowRunID, arg.SuccessTaskResults)
	return err
}

const updateFlowRunTaskStatuses = `-- name: UpdateFlowRunTaskStatuses :exec
UPDATE flow_runs 
SET task_statuses = $2, 
    updated_at = NOW()
WHERE flow_run_id = $1
`

type UpdateFlowRunTaskStatusesParams struct {
	FlowRunID    uuid.UUID `db:"flow_run_id" json:"flow_run_id"`
	TaskStatuses JsonRaw   `db:"task_statuses" json:"task_statuses"`
}

func (q *Queries) UpdateFlowRunTaskStatuses(ctx context.Context, arg UpdateFlowRunTaskStatusesParams) error {
	_, err := q.db.Exec(ctx, updateFlowRunTaskStatuses, arg.FlowRunID, arg.TaskStatuses)
	return err
}
