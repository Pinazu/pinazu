// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: flows.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createFlow = `-- name: CreateFlow :one
INSERT INTO flows (id, name, description, parameters_schema, engine, additional_info, tags, code_location, entrypoint)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, name, description, engine, additional_info, tags, created_at, updated_at, parameters_schema, code_location, entrypoint
`

type CreateFlowParams struct {
	ID               uuid.UUID   `db:"id" json:"id"`
	Name             string      `db:"name" json:"name"`
	Description      pgtype.Text `db:"description" json:"description"`
	ParametersSchema JsonRaw     `db:"parameters_schema" json:"parameters_schema"`
	Engine           string      `db:"engine" json:"engine"`
	AdditionalInfo   JsonRaw     `db:"additional_info" json:"additional_info"`
	Tags             []string    `db:"tags" json:"tags"`
	CodeLocation     pgtype.Text `db:"code_location" json:"code_location"`
	Entrypoint       pgtype.Text `db:"entrypoint" json:"entrypoint"`
}

func (q *Queries) CreateFlow(ctx context.Context, arg CreateFlowParams) (Flow, error) {
	row := q.db.QueryRow(ctx, createFlow,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ParametersSchema,
		arg.Engine,
		arg.AdditionalInfo,
		arg.Tags,
		arg.CodeLocation,
		arg.Entrypoint,
	)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Engine,
		&i.AdditionalInfo,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParametersSchema,
		&i.CodeLocation,
		&i.Entrypoint,
	)
	return i, err
}

const deleteFlow = `-- name: DeleteFlow :exec
DELETE FROM flows WHERE id = $1
`

func (q *Queries) DeleteFlow(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFlow, id)
	return err
}

const getFlowById = `-- name: GetFlowById :one
SELECT id, name, description, engine, additional_info, tags, created_at, updated_at, parameters_schema, code_location, entrypoint FROM flows WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFlowById(ctx context.Context, id uuid.UUID) (Flow, error) {
	row := q.db.QueryRow(ctx, getFlowById, id)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Engine,
		&i.AdditionalInfo,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParametersSchema,
		&i.CodeLocation,
		&i.Entrypoint,
	)
	return i, err
}

const getFlows = `-- name: GetFlows :many
SELECT id, name, description, engine, additional_info, tags, created_at, updated_at, parameters_schema, code_location, entrypoint FROM flows ORDER BY name LIMIT $1 OFFSET $2
`

type GetFlowsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetFlows(ctx context.Context, arg GetFlowsParams) ([]Flow, error) {
	rows, err := q.db.Query(ctx, getFlows, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Flow{}
	for rows.Next() {
		var i Flow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Engine,
			&i.AdditionalInfo,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ParametersSchema,
			&i.CodeLocation,
			&i.Entrypoint,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlow = `-- name: UpdateFlow :one
UPDATE flows
SET name = $1, description = $2, parameters_schema = $3, engine = $4, additional_info = $5, tags = $6, code_location = $7, entrypoint = $8, updated_at = CURRENT_TIMESTAMP
WHERE id = $9
RETURNING id, name, description, engine, additional_info, tags, created_at, updated_at, parameters_schema, code_location, entrypoint
`

type UpdateFlowParams struct {
	Name             string      `db:"name" json:"name"`
	Description      pgtype.Text `db:"description" json:"description"`
	ParametersSchema JsonRaw     `db:"parameters_schema" json:"parameters_schema"`
	Engine           string      `db:"engine" json:"engine"`
	AdditionalInfo   JsonRaw     `db:"additional_info" json:"additional_info"`
	Tags             []string    `db:"tags" json:"tags"`
	CodeLocation     pgtype.Text `db:"code_location" json:"code_location"`
	Entrypoint       pgtype.Text `db:"entrypoint" json:"entrypoint"`
	ID               uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateFlow(ctx context.Context, arg UpdateFlowParams) (Flow, error) {
	row := q.db.QueryRow(ctx, updateFlow,
		arg.Name,
		arg.Description,
		arg.ParametersSchema,
		arg.Engine,
		arg.AdditionalInfo,
		arg.Tags,
		arg.CodeLocation,
		arg.Entrypoint,
		arg.ID,
	)
	var i Flow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Engine,
		&i.AdditionalInfo,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ParametersSchema,
		&i.CodeLocation,
		&i.Entrypoint,
	)
	return i, err
}
