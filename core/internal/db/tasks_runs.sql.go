// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tasks_runs.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTasksRun = `-- name: CreateTasksRun :one
INSERT INTO tasks_runs (task_id) VALUES ($1) RETURNING task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at
`

func (q *Queries) CreateTasksRun(ctx context.Context, taskID string) (TasksRun, error) {
	row := q.db.QueryRow(ctx, createTasksRun, taskID)
	var i TasksRun
	err := row.Scan(
		&i.TaskRunID,
		&i.TaskID,
		&i.Status,
		&i.CreatedAt,
		&i.CurrentLoops,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const deleteOldTaskRun = `-- name: DeleteOldTaskRun :exec
DELETE FROM tasks_runs 
WHERE created_at < $1 
AND status IN ('FINISHED', 'FAILED')
`

func (q *Queries) DeleteOldTaskRun(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldTaskRun, createdAt)
	return err
}

const deleteTaskRun = `-- name: DeleteTaskRun :exec
DELETE FROM tasks_runs WHERE task_run_id = $1
`

func (q *Queries) DeleteTaskRun(ctx context.Context, taskRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTaskRun, taskRunID)
	return err
}

const getCurrentTaskRunByTaskID = `-- name: GetCurrentTaskRunByTaskID :one
SELECT task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at FROM tasks_runs
WHERE task_id = $1 AND status IN ('PAUSE', 'SCHEDULED', 'RUNNING')
`

func (q *Queries) GetCurrentTaskRunByTaskID(ctx context.Context, taskID string) (TasksRun, error) {
	row := q.db.QueryRow(ctx, getCurrentTaskRunByTaskID, taskID)
	var i TasksRun
	err := row.Scan(
		&i.TaskRunID,
		&i.TaskID,
		&i.Status,
		&i.CreatedAt,
		&i.CurrentLoops,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const getPendingTaskRun = `-- name: GetPendingTaskRun :many
SELECT task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at FROM tasks_runs 
WHERE status IN ('SCHEDULED', 'PAUSE') 
ORDER BY created_at ASC
`

func (q *Queries) GetPendingTaskRun(ctx context.Context) ([]TasksRun, error) {
	rows, err := q.db.Query(ctx, getPendingTaskRun)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TasksRun{}
	for rows.Next() {
		var i TasksRun
		if err := rows.Scan(
			&i.TaskRunID,
			&i.TaskID,
			&i.Status,
			&i.CreatedAt,
			&i.CurrentLoops,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunningTaskRun = `-- name: GetRunningTaskRun :many
SELECT task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at FROM tasks_runs 
WHERE status = 'RUNNING' 
ORDER BY created_at ASC
`

func (q *Queries) GetRunningTaskRun(ctx context.Context) ([]TasksRun, error) {
	rows, err := q.db.Query(ctx, getRunningTaskRun)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TasksRun{}
	for rows.Next() {
		var i TasksRun
		if err := rows.Scan(
			&i.TaskRunID,
			&i.TaskID,
			&i.Status,
			&i.CreatedAt,
			&i.CurrentLoops,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskRunByStatus = `-- name: GetTaskRunByStatus :many
SELECT task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at FROM tasks_runs 
WHERE status = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetTaskRunByStatus(ctx context.Context, status TaskRunStatus) ([]TasksRun, error) {
	rows, err := q.db.Query(ctx, getTaskRunByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TasksRun{}
	for rows.Next() {
		var i TasksRun
		if err := rows.Scan(
			&i.TaskRunID,
			&i.TaskID,
			&i.Status,
			&i.CreatedAt,
			&i.CurrentLoops,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskRunByTaskID = `-- name: GetTaskRunByTaskID :many
SELECT task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at FROM tasks_runs 
WHERE task_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) GetTaskRunByTaskID(ctx context.Context, taskID string) ([]TasksRun, error) {
	rows, err := q.db.Query(ctx, getTaskRunByTaskID, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TasksRun{}
	for rows.Next() {
		var i TasksRun
		if err := rows.Scan(
			&i.TaskRunID,
			&i.TaskID,
			&i.Status,
			&i.CreatedAt,
			&i.CurrentLoops,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksRun = `-- name: GetTasksRun :one
SELECT task_run_id, task_id, status, created_at, current_loops, updated_at, started_at, finished_at FROM tasks_runs WHERE task_run_id = $1
`

func (q *Queries) GetTasksRun(ctx context.Context, taskRunID uuid.UUID) (TasksRun, error) {
	row := q.db.QueryRow(ctx, getTasksRun, taskRunID)
	var i TasksRun
	err := row.Scan(
		&i.TaskRunID,
		&i.TaskID,
		&i.Status,
		&i.CreatedAt,
		&i.CurrentLoops,
		&i.UpdatedAt,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return i, err
}

const incrementTaskRunLoops = `-- name: IncrementTaskRunLoops :exec
UPDATE tasks_runs 
SET current_loops = current_loops + 1,
    updated_at = NOW()
WHERE task_run_id = $1
`

func (q *Queries) IncrementTaskRunLoops(ctx context.Context, taskRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementTaskRunLoops, taskRunID)
	return err
}

const listTaskRun = `-- name: ListTaskRun :many
SELECT tr.task_run_id, tr.task_id, tr.status, tr.created_at, tr.current_loops, tr.updated_at, tr.started_at, tr.finished_at, t.thread_id, t.max_request_loop
FROM tasks_runs tr
JOIN tasks t ON tr.task_id = t.id
ORDER BY tr.created_at DESC
LIMIT $1 OFFSET $2
`

type ListTaskRunParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListTaskRunRow struct {
	TaskRunID      uuid.UUID          `db:"task_run_id" json:"task_run_id"`
	TaskID         string             `db:"task_id" json:"task_id"`
	Status         TaskRunStatus      `db:"status" json:"status"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	CurrentLoops   int32              `db:"current_loops" json:"current_loops"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	StartedAt      pgtype.Timestamptz `db:"started_at" json:"started_at"`
	FinishedAt     pgtype.Timestamptz `db:"finished_at" json:"finished_at"`
	ThreadID       uuid.UUID          `db:"thread_id" json:"thread_id"`
	MaxRequestLoop int32              `db:"max_request_loop" json:"max_request_loop"`
}

func (q *Queries) ListTaskRun(ctx context.Context, arg ListTaskRunParams) ([]ListTaskRunRow, error) {
	rows, err := q.db.Query(ctx, listTaskRun, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTaskRunRow{}
	for rows.Next() {
		var i ListTaskRunRow
		if err := rows.Scan(
			&i.TaskRunID,
			&i.TaskID,
			&i.Status,
			&i.CreatedAt,
			&i.CurrentLoops,
			&i.UpdatedAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.ThreadID,
			&i.MaxRequestLoop,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskRunCurrentLoops = `-- name: UpdateTaskRunCurrentLoops :exec
UPDATE tasks_runs 
SET current_loops = $2, 
    updated_at = NOW()
WHERE task_run_id = $1
`

type UpdateTaskRunCurrentLoopsParams struct {
	TaskRunID    uuid.UUID `db:"task_run_id" json:"task_run_id"`
	CurrentLoops int32     `db:"current_loops" json:"current_loops"`
}

func (q *Queries) UpdateTaskRunCurrentLoops(ctx context.Context, arg UpdateTaskRunCurrentLoopsParams) error {
	_, err := q.db.Exec(ctx, updateTaskRunCurrentLoops, arg.TaskRunID, arg.CurrentLoops)
	return err
}

const updateTaskRunStartedAt = `-- name: UpdateTaskRunStartedAt :exec
UPDATE tasks_runs 
SET started_at = NOW(),
    updated_at = NOW()
WHERE task_run_id = $1 AND started_at IS NULL
`

func (q *Queries) UpdateTaskRunStartedAt(ctx context.Context, taskRunID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateTaskRunStartedAt, taskRunID)
	return err
}

const updateTaskRunStatus = `-- name: UpdateTaskRunStatus :exec
UPDATE tasks_runs
SET status = $1,
    updated_at = NOW()
WHERE task_run_id = $2
`

type UpdateTaskRunStatusParams struct {
	Status    TaskRunStatus `db:"status" json:"status"`
	TaskRunID uuid.UUID     `db:"task_run_id" json:"task_run_id"`
}

func (q *Queries) UpdateTaskRunStatus(ctx context.Context, arg UpdateTaskRunStatusParams) error {
	_, err := q.db.Exec(ctx, updateTaskRunStatus, arg.Status, arg.TaskRunID)
	return err
}

const updateTaskRunStatusByTaskID = `-- name: UpdateTaskRunStatusByTaskID :exec
UPDATE tasks_runs
SET status = $1, updated_at = NOW()
WHERE task_id = $2 AND status IN ('SCHEDULED', 'RUNNING', 'PENDING')
`

type UpdateTaskRunStatusByTaskIDParams struct {
	Status TaskRunStatus `db:"status" json:"status"`
	TaskID string        `db:"task_id" json:"task_id"`
}

func (q *Queries) UpdateTaskRunStatusByTaskID(ctx context.Context, arg UpdateTaskRunStatusByTaskIDParams) error {
	_, err := q.db.Exec(ctx, updateTaskRunStatusByTaskID, arg.Status, arg.TaskID)
	return err
}

const updateTaskRunStatusWithTimestamps = `-- name: UpdateTaskRunStatusWithTimestamps :exec
UPDATE tasks_runs 
SET status = $1::text, 
    updated_at = NOW(),
    started_at = CASE WHEN $1::text = 'RUNNING' AND started_at IS NULL THEN NOW() ELSE started_at END,
    finished_at = CASE WHEN $1::text IN ('FINISHED', 'FAILED') AND finished_at IS NULL THEN NOW() ELSE finished_at END
WHERE task_run_id = $2
`

type UpdateTaskRunStatusWithTimestampsParams struct {
	Status    string    `db:"status" json:"status"`
	TaskRunID uuid.UUID `db:"task_run_id" json:"task_run_id"`
}

func (q *Queries) UpdateTaskRunStatusWithTimestamps(ctx context.Context, arg UpdateTaskRunStatusWithTimestampsParams) error {
	_, err := q.db.Exec(ctx, updateTaskRunStatusWithTimestamps, arg.Status, arg.TaskRunID)
	return err
}
