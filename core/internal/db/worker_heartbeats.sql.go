// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: worker_heartbeats.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteInactiveWorkers = `-- name: DeleteInactiveWorkers :exec
DELETE FROM worker_heartbeats 
WHERE status = 'INACTIVE' 
AND updated_at < $1
`

func (q *Queries) DeleteInactiveWorkers(ctx context.Context, updatedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteInactiveWorkers, updatedAt)
	return err
}

const deleteWorkerHeartbeat = `-- name: DeleteWorkerHeartbeat :exec
DELETE FROM worker_heartbeats WHERE worker_id = $1
`

func (q *Queries) DeleteWorkerHeartbeat(ctx context.Context, workerID string) error {
	_, err := q.db.Exec(ctx, deleteWorkerHeartbeat, workerID)
	return err
}

const getActiveWorkers = `-- name: GetActiveWorkers :many
SELECT worker_id, worker_name, status, last_heartbeat, worker_info, created_at, updated_at FROM worker_heartbeats 
WHERE status = 'ACTIVE' 
AND last_heartbeat > NOW() - INTERVAL '5 minutes'
ORDER BY last_heartbeat DESC
`

func (q *Queries) GetActiveWorkers(ctx context.Context) ([]WorkerHeartbeat, error) {
	rows, err := q.db.Query(ctx, getActiveWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkerHeartbeat{}
	for rows.Next() {
		var i WorkerHeartbeat
		if err := rows.Scan(
			&i.WorkerID,
			&i.WorkerName,
			&i.Status,
			&i.LastHeartbeat,
			&i.WorkerInfo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWorkers = `-- name: GetAllWorkers :many
SELECT worker_id, worker_name, status, last_heartbeat, worker_info, created_at, updated_at FROM worker_heartbeats 
ORDER BY last_heartbeat DESC
`

func (q *Queries) GetAllWorkers(ctx context.Context) ([]WorkerHeartbeat, error) {
	rows, err := q.db.Query(ctx, getAllWorkers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkerHeartbeat{}
	for rows.Next() {
		var i WorkerHeartbeat
		if err := rows.Scan(
			&i.WorkerID,
			&i.WorkerName,
			&i.Status,
			&i.LastHeartbeat,
			&i.WorkerInfo,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkerHeartbeat = `-- name: GetWorkerHeartbeat :one
SELECT worker_id, worker_name, status, last_heartbeat, worker_info, created_at, updated_at FROM worker_heartbeats WHERE worker_id = $1
`

func (q *Queries) GetWorkerHeartbeat(ctx context.Context, workerID string) (WorkerHeartbeat, error) {
	row := q.db.QueryRow(ctx, getWorkerHeartbeat, workerID)
	var i WorkerHeartbeat
	err := row.Scan(
		&i.WorkerID,
		&i.WorkerName,
		&i.Status,
		&i.LastHeartbeat,
		&i.WorkerInfo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkerStats = `-- name: GetWorkerStats :one
SELECT 
    COUNT(*) as total_workers,
    COUNT(*) FILTER (WHERE status = 'ACTIVE') as active_workers,
    COUNT(*) FILTER (WHERE status = 'INACTIVE') as inactive_workers,
    COUNT(*) FILTER (WHERE status = 'FAILED') as failed_workers
FROM worker_heartbeats
`

type GetWorkerStatsRow struct {
	TotalWorkers    int64 `db:"total_workers" json:"total_workers"`
	ActiveWorkers   int64 `db:"active_workers" json:"active_workers"`
	InactiveWorkers int64 `db:"inactive_workers" json:"inactive_workers"`
	FailedWorkers   int64 `db:"failed_workers" json:"failed_workers"`
}

func (q *Queries) GetWorkerStats(ctx context.Context) (GetWorkerStatsRow, error) {
	row := q.db.QueryRow(ctx, getWorkerStats)
	var i GetWorkerStatsRow
	err := row.Scan(
		&i.TotalWorkers,
		&i.ActiveWorkers,
		&i.InactiveWorkers,
		&i.FailedWorkers,
	)
	return i, err
}

const markStaleWorkersInactive = `-- name: MarkStaleWorkersInactive :exec
UPDATE worker_heartbeats 
SET status = 'INACTIVE',
    updated_at = NOW()
WHERE last_heartbeat < $1 
AND status = 'ACTIVE'
`

func (q *Queries) MarkStaleWorkersInactive(ctx context.Context, lastHeartbeat pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, markStaleWorkersInactive, lastHeartbeat)
	return err
}

const updateWorkerStatus = `-- name: UpdateWorkerStatus :exec
UPDATE worker_heartbeats 
SET status = $2,
    updated_at = NOW()
WHERE worker_id = $1
`

type UpdateWorkerStatusParams struct {
	WorkerID string       `db:"worker_id" json:"worker_id"`
	Status   WorkerStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateWorkerStatus(ctx context.Context, arg UpdateWorkerStatusParams) error {
	_, err := q.db.Exec(ctx, updateWorkerStatus, arg.WorkerID, arg.Status)
	return err
}

const upsertWorkerHeartbeat = `-- name: UpsertWorkerHeartbeat :one
INSERT INTO worker_heartbeats (
    worker_id,
    worker_name,
    status,
    last_heartbeat,
    worker_info
) VALUES (
    $1, $2, $3, $4, $5
) ON CONFLICT (worker_id) DO UPDATE SET
    worker_name = EXCLUDED.worker_name,
    status = EXCLUDED.status,
    last_heartbeat = EXCLUDED.last_heartbeat,
    worker_info = EXCLUDED.worker_info,
    updated_at = NOW()
RETURNING worker_id, worker_name, status, last_heartbeat, worker_info, created_at, updated_at
`

type UpsertWorkerHeartbeatParams struct {
	WorkerID      string             `db:"worker_id" json:"worker_id"`
	WorkerName    pgtype.Text        `db:"worker_name" json:"worker_name"`
	Status        WorkerStatus       `db:"status" json:"status"`
	LastHeartbeat pgtype.Timestamptz `db:"last_heartbeat" json:"last_heartbeat"`
	WorkerInfo    JsonRaw            `db:"worker_info" json:"worker_info"`
}

func (q *Queries) UpsertWorkerHeartbeat(ctx context.Context, arg UpsertWorkerHeartbeatParams) (WorkerHeartbeat, error) {
	row := q.db.QueryRow(ctx, upsertWorkerHeartbeat,
		arg.WorkerID,
		arg.WorkerName,
		arg.Status,
		arg.LastHeartbeat,
		arg.WorkerInfo,
	)
	var i WorkerHeartbeat
	err := row.Scan(
		&i.WorkerID,
		&i.WorkerName,
		&i.Status,
		&i.LastHeartbeat,
		&i.WorkerInfo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
