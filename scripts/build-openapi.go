//go:build ignore

package main

import (
	"fmt"
	"maps"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oasdiff/yaml"
)

func loadYAMLFile[T any](filePath string) (*T, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("error reading %s: %w", filePath, err)
	}

	result := new(T)
	if err := yaml.Unmarshal(data, result); err != nil {
		return nil, fmt.Errorf("error parsing %s: %w", filePath, err)
	}

	return result, nil
}

type OpenAPIPaths map[string]*openapi3.PathItem

func mergeOpenAPIFiles() error {
	// Get project root directory
	wd, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("error getting working directory: %w", err)
	}
	rootDir := wd

	apiDir := filepath.Join(rootDir, "api")

	// Load base configuration
	baseFile := filepath.Join(apiDir, "base.yaml")
	if _, err := os.Stat(baseFile); os.IsNotExist(err) {
		return fmt.Errorf("error: Base file %s not found", baseFile)
	}

	spec, err := loadYAMLFile[openapi3.T](baseFile)
	if err != nil {
		return err
	}

	// Initialize paths and components if not present
	if spec.Paths == nil {
		spec.Paths = &openapi3.Paths{}
	}
	if spec.Components == nil {
		spec.Components = &openapi3.Components{
			Schemas: make(openapi3.Schemas),
		}
	}

	// Merge path files
	pathsDir := filepath.Join(apiDir, "paths")
	if _, err := os.Stat(pathsDir); err == nil {
		files, err := filepath.Glob(filepath.Join(pathsDir, "*.yaml"))
		if err != nil {
			return fmt.Errorf("error reading paths directory: %w", err)
		}
		for _, pathFile := range files {
			fileName := filepath.Base(pathFile)
			fmt.Printf("Merging paths from %s\n", fileName)

			pathsData, err := loadYAMLFile[OpenAPIPaths](pathFile)
			if err != nil {
				return err
			}

			if pathsData != nil {
				for k, v := range *pathsData {
					// For each path item, ensure that each operation have a valid response
					// Raise an error if any operation is missing a response
					if (v.Get != nil && v.Get.Responses == nil) ||
						(v.Post != nil && v.Post.Responses == nil) ||
						(v.Put != nil && v.Put.Responses == nil) ||
						(v.Delete != nil && v.Delete.Responses == nil) ||
						(v.Patch != nil && v.Patch.Responses == nil) ||
						(v.Options != nil && v.Options.Responses == nil) ||
						(v.Head != nil && v.Head.Responses == nil) ||
						(v.Trace != nil && v.Trace.Responses == nil) ||
						(v.Connect != nil && v.Connect.Responses == nil) {
						return fmt.Errorf("error: Operation in path %s is missing responses", k)
					}
					spec.Paths.Set(k, v)
				}
			}
		}
	}

	// Merge schema files
	schemasDir := filepath.Join(apiDir, "schemas")
	if _, err := os.Stat(schemasDir); err == nil {
		files, err := filepath.Glob(filepath.Join(schemasDir, "*.yaml"))
		if err != nil {
			return fmt.Errorf("error reading schemas directory: %w", err)
		}

		// schemas := components["schemas"].(map[string]interface{})
		for _, schemaFile := range files {
			fileName := filepath.Base(schemaFile)
			fmt.Printf("Merging schemas from %s\n", fileName)

			schemasData, err := loadYAMLFile[openapi3.Schemas](schemaFile)
			if err != nil {
				return err
			}
			for k, v := range *schemasData {
				spec.Components.Schemas[k] = v
			}
		}
	}
	// Merge parameters
	parametersDir := filepath.Join(apiDir, "parameters")
	if _, err := os.Stat(parametersDir); err == nil {
		files, err := filepath.Glob(filepath.Join(parametersDir, "*.yaml"))
		if err != nil {
			return fmt.Errorf("error reading parameters directory: %w", err)
		}
		for _, paramFile := range files {
			fileName := filepath.Base(paramFile)
			fmt.Printf("Merging parameters from %s\n", fileName)

			paramsData, err := loadYAMLFile[openapi3.ParametersMap](paramFile)
			if err != nil {
				return err
			}
			if spec.Components.Parameters == nil {
				spec.Components.Parameters = make(openapi3.ParametersMap)
			}
			maps.Copy(spec.Components.Parameters, *paramsData)
		}
	}

	// Write merged specification
	outputFile := filepath.Join(apiDir, "openapi.yaml")

	// Remove existing file and its read-only protection if it exists
	if _, err := os.Stat(outputFile); err == nil {
		if err := os.Chmod(outputFile, 0644); err != nil {
			return fmt.Errorf("error making file writable: %w", err)
		}
	}

	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}
	defer file.Close()

	// Add DO NOT EDIT header
	header := `# DO NOT EDIT - This file is auto-generated by scripts/build-openapi.go
# To make changes, edit files in api/base.yaml, api/paths/, and api/schemas/
# Then run: make build-api

`
	if _, err := file.WriteString(header); err != nil {
		return fmt.Errorf("error writing header: %w", err)
	}

	// Marshal and write YAML
	data, err := yaml.Marshal(spec)
	if err != nil {
		return fmt.Errorf("error marshalling OpenAPI spec: %w", err)
	}

	if _, err := file.Write(data); err != nil {
		return fmt.Errorf("error writing OpenAPI spec to file: %w", err)
	}

	// Make the file read-only to prevent accidental edits
	if err := os.Chmod(outputFile, 0444); err != nil {
		return fmt.Errorf("error making file read-only: %w", err)
	}

	fmt.Printf("âœ… Successfully merged OpenAPI specification to %s (read-only)\n", outputFile)
	// Read the file to verify
	mergedSpec, err := os.ReadFile(outputFile)
	if err != nil {
		return fmt.Errorf("error reading merged file: %w", err)
	}
	parseSpec, err := openapi3.NewLoader().LoadFromData(mergedSpec)
	if err != nil {
		return fmt.Errorf("error loading merged OpenAPI spec: %w", err)
	}
	if parseSpec == nil {
		return fmt.Errorf("error: Merged OpenAPI spec is nil")
	}
	if err := generatePythonModels(parseSpec); err != nil {
		fmt.Printf("error generating python models: %v\n", err)
	}

	return nil
}

func generatePythonModels(spec *openapi3.T) error {
	// Get project root directory
	rootDir, err := os.Getwd()
	if err != nil {
		return fmt.Errorf("error getting working directory: %w", err)
	}
	// Open template files
	pythonPath := filepath.Join(rootDir, "python", "pinazu-py")
	modelTemplatePath := filepath.Join(pythonPath, "templates", "models.py.gotmpl")
	modelTemplate, err := os.ReadFile(modelTemplatePath)
	if err != nil {
		return fmt.Errorf("error reading model template file: %w", err)
	}
	tmpl, err := template.New("models").Funcs(template.FuncMap{
		"getClassNameFromRef": func(s string) string {
			// Receive #/components/schemas/<className>
			// Return class name
			parts := strings.Split(s, "/")
			if len(parts) > 0 {
				return parts[len(parts)-1]
			}
			return ""
		},
		"toPythonType": func(prop *openapi3.SchemaRef) string {
			// if string type, check for compatible data type in python, e.g. uuid / date-time
			if prop.Value.Type.Includes(openapi3.TypeString) {
				if prop.Value.Format == "uuid" {
					return "UUID"
				}
				if prop.Value.Format == "date-time" {
					return "datetime"
				}
			}
			if prop.Value.Type.Includes(openapi3.TypeBoolean) {
				return "bool"
			}
			return "str"
		},
		"toPythonTypeWithOptional": func(prop *openapi3.SchemaRef, fieldName string, required []string, nullable bool) string {
			// Get base type
			baseType := "str"
			if prop.Value.Type.Includes(openapi3.TypeString) {
				if prop.Value.Format == "uuid" {
					baseType = "UUID"
				} else if prop.Value.Format == "date-time" {
					baseType = "datetime"
				}
			} else if prop.Value.Type.Includes(openapi3.TypeBoolean) {
				baseType = "bool"
			} else if prop.Value.Type.Includes(openapi3.TypeObject) {
				baseType = "dict"
			} else if prop.Value.Type.Includes(openapi3.TypeArray) {
				// Handle array types
				if prop.Value.Items != nil {
					if prop.Value.Items.Ref != "" {
						// Extract class name from reference
						parts := strings.Split(prop.Value.Items.Ref, "/")
						if len(parts) > 0 {
							className := parts[len(parts)-1]
							baseType = fmt.Sprintf("list[%s]", className)
						} else {
							baseType = "list"
						}
					} else {
						baseType = "list"
					}
				} else {
					baseType = "list"
				}
			} else if prop.Value.Type.Includes(openapi3.TypeInteger) {
				baseType = "int"
			}

			// Check if field is required
			isRequired := false
			for _, req := range required {
				if req == fieldName {
					isRequired = true
					break
				}
			}

			// If nullable or not required, make it optional
			if nullable || !isRequired {
				return fmt.Sprintf("Optional[%s] = None", baseType)
			}

			return baseType
		},
	}).Parse(string(modelTemplate))
	if err != nil {
		return fmt.Errorf("error parsing model template: %w", err)
	}
	type templateStruct struct {
		Schemas openapi3.Schemas
	}
	// for key, schema := range spec.Components.Schemas {
	// 	fmt.Printf("Schema %s: %v\n", key, schema.Value.Type)
	// 	// if object type
	// 	if schema.Value.Type.Includes(openapi3.TypeObject) {
	// 		for propKey, prop := range schema.Value.Properties {
	// 			fmt.Printf("  Property %s: %v\n", propKey, prop.Value.Type)
	// 			if prop.Value.Type.Includes(openapi3.TypeArray) {
	// 				fmt.Printf("    Items: %v\n", prop.Value.Items.Value.Type)
	// 				// If it is object
	// 				if prop.Value.Items.Value.Type.Includes(openapi3.TypeObject) {
	// 					fmt.Printf("    Items Ref: %s\n", prop.Value.Items.RefString())

	// 				}
	// 			}
	// 		}
	// 	}
	// }
	outfile, err := os.Create(filepath.Join(pythonPath, "src", "pinazu", "api", "models_generated.py"))
	if err != nil {
		return fmt.Errorf("error creating output file: %w", err)
	}
	defer outfile.Close()

	err = tmpl.Execute(outfile, templateStruct{
		Schemas: spec.Components.Schemas,
	})
	return err
}

func main() {
	if err := mergeOpenAPIFiles(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}
